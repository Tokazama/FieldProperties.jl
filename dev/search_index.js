var documenterSearchIndex = {"docs":
[{"location":"assign_properties/#Assigning-Properties-1","page":"Assigning Properties","title":"Assigning Properties","text":"","category":"section"},{"location":"assign_properties/#","page":"Assigning Properties","title":"Assigning Properties","text":"@properties","category":"page"},{"location":"assign_properties/#FieldProperties.@properties","page":"Assigning Properties","title":"FieldProperties.@properties","text":"@properties T block\n\nSyntactic sugar for custom getproperty, setproperty!, and propertynames methods. For any type T passed to @properties these methods will be rewritten from their default.\n\nExamples\n\nThe following syntax assigns property names to function calls.\n\njulia> using FieldProperties\n\njulia> mutable struct MyType\n           x::Int\n       end\n\njulia> @properties MyType begin\n           xint(self) = getfield(self, :x)\n           xint!(self, val) = setfield!(self, :x, val)\n           hello(self) = \"hello\"\n       end\n\njulia> mt = MyType(1)\nMyType(1)\n\njulia> mt.xint\n1\n\njulia> mt.xint = 2\n2\n\njulia> mt.xint\n2\n\njulia> mt.hello\n\"hello\"\n\njulia> propertynames(mt)\n(:xint, :hello)\n\njulia> mt.x\nERROR: Property x not found\n[...]\n\nThere are three things you should take away from this:\n\ngetproperty, setproperty!, and propertynames are completely overwritten here\nAny property assignment that ends with ! is used to assign a setproperty!\nMyType not longer can access the x field via mt.x (because of the first point).\n\nIt can be somewhat tedious to write out every getfield and setfield method, so let's redo this using => to assign fields\n\njulia> @properties MyType begin\n           xint(self) => :x\n           xint!(self, val) => :x\n           hello(self) = \"hello\"\n       end\n\njulia> mt = MyType(1)\nMyType(1)\n\njulia> mt.xint\n1\n\njulia> mt.xint = 2\n2\n\njulia> mt.xint\n2\n\njulia> mt.hello\n\"hello\"\n\njulia> propertynames(mt)\n(:xint, :hello)\n\njulia> mt.x\nERROR: Property x not found\n[...]\n\nSometimes we want to use a modular approach to constructing a type. The following example requires users to know where to find the x1, x2, and x3 fields.\n\njulia> mutable struct PropList1\n           x2::Int\n       end\n\njulia> mutable struct PropList2\n           x3::Int\n       end\n\njulia> mutable struct MyProperties\n           x1::Int\n           l1::PropList1\n           l2::PropList2\n       end\n\njulia> mp = MyProperties(1, PropList1(2), PropList2(3))\nMyProperties(1, PropList1(2), PropList2(3))\n\njulia> mp.x1\n1\n\njulia> mp.l1.x2  # obnoxious for users\n2\n\njulia> mp.l2.x3  # also obnoxious for users\n3\n\nThe following syntax tells our property methods to search through nested fields.\n\njulia> @properties MyProperties begin\n           x1(self) => :x1\n           x1!(self, val) => :x1\n           Any(self) => (:l1, :l2)\n           Any!(self, val) => (:l1, :l2)\n       end\n\njulia> propertynames(mp)\n(:x1, :x2, :x3)\n\njulia> mp.x1\n1\n\njulia> mp.x2\n2\n\njulia> mp.x3\n3\n\nThe last two methods (Any(x) and Any!(x, val)) tell the getproperty and setproperty! methods search the l1 and l2 fields for any property that isn't :x1.\n\nThe lowered code is:\n\njulia> @macroexpand @properties MyProperties begin\n                  x1(self) => :x1\n                  x1!(self, val) => :x1\n                  Any(self) => (:l1, :l2)\n                  Any!(self, val) => (:l1, :l2)\n              end\nquote\n    function Base.getproperty(self::MyProperties, p::Symbol)\n        if p === :x1\n            getfield(self, :x1)\n        else\n            if hasproperty(getfield(self, :l1), p)\n                getproperty(getfield(self, :l1), p)\n            else\n                getproperty(getfield(self, :l2), p)\n            end\n        end\n    end\n    function Base.setproperty!(self::MyProperties, p::Symbol, val)\n        if p === :x1\n            setfield!(self, :x1, val)\n        else\n            if hasproperty(getfield(self, :l1), p)\n                setproperty!(getfield(self, :l1), p, val)\n            else\n                setproperty!(getfield(self, :l2), p, val)\n            end\n        end\n    end\n    function Base.propertynames(self::MyProperties)\n        (:x1, propertynames(getfield(self, :l1))..., propertynames(getfield(self, :l2))...)\n    end\nend\n\nNote that the the :l1 and l2 fields are searched in the same order they are called inside the macro (e.g., Any(x) => (:l1, :l2) results in searching :l1 then :l2).\n\n\n\n\n\n","category":"macro"},{"location":"structures_with_properties/#Structures-With-Properties-1","page":"Structures With Properties","title":"Structures With Properties","text":"","category":"section"},{"location":"structures_with_properties/#","page":"Structures With Properties","title":"Structures With Properties","text":"Although properties can be used flexibly with different structures, it may be easier to take advantage of the provided AbstractMetadata type. In the following example we take advantage of the Description and DictExtension. These provide a method of describing a structure and an extensible pool for storing an arbitrary number of properties.","category":"page"},{"location":"structures_with_properties/#","page":"Structures With Properties","title":"Structures With Properties","text":"julia> mutable struct MyProperties{M} <: AbstractMetadata{M}\n           my_description::String\n           my_properties::M\n       end","category":"page"},{"location":"structures_with_properties/#","page":"Structures With Properties","title":"Structures With Properties","text":"Binding Description and DictExtension to specific fields is accomplished through @assignprops. Several other methods specific to MyProperties are created to provide property like behavior. Most notably, the methods from base overwritten are getproperty, setproperty!, and propertynames.","category":"page"},{"location":"structures_with_properties/#","page":"Structures With Properties","title":"Structures With Properties","text":"julia> @properties MyProperties begin\n           description(x) => :my_description\n           description!(x, val) => :my_description\n           Any(x) => :my_properties\n           Any!(x, val) => (:my_properties)\n       end\n\njulia> m = MyProperties(\"\", Dict{Symbol,Any}())\nMyProperties{Dict{Symbol,Any}} with 1 entry\n    description:\n\njulia> propertynames(m)\n(:description,)","category":"page"},{"location":"structures_with_properties/#","page":"Structures With Properties","title":"Structures With Properties","text":"julia> description(m)\n\"\"\n\njulia> description!(m, \"foo\")\nMyProperties{Dict{Symbol,Any}} with 1 entry\n    description: foo\n\njulia> description(m)\n\"foo\"\n\njulia> m.description = \"bar\"\n\"bar\"\n\njulia> description(m)\n\"bar\"\n\njulia> m.description\n\"bar\"","category":"page"},{"location":"structures_with_properties/#","page":"Structures With Properties","title":"Structures With Properties","text":"Optional properties can be assigned to the DictExtension using the DictExtension(Propert1, Property2) syntax.","category":"page"},{"location":"structures_with_properties/#","page":"Structures With Properties","title":"Structures With Properties","text":"julia> @defprop CalibrationMaximum{:calmax}\n\njulia> propdefault(::CalibrationMaximumType, x::AbstractArray) = maximum(x)\n\njulia> proptype(::CalibrationMaximumType, ::Type{<:AbstractArray{T,N}}) where {T,N} = T\n\njulia> @defprop CalibrationMinimum{:calmin}\n\njulia> propdefault(::CalibrationMinimumType, x::AbstractArray) = minimum(x)\n\njulia> proptype(::CalibrationMinimumType, ::Type{<:AbstractArray{T,N}}) where {T,N} = T\n\njulia> struct MyArray{T,N,P<:AbstractArray{T,N},M<:AbstractDict{Symbol,Any}} <: AbstractArray{T,N}\n           _parent::P\n           my_properties::M\n       end\n\njulia> Base.parent(m::MyArray) = getfield(m, :_parent)\n\njulia> Base.size(m::MyArray) = size(parent(m))\n\njulia> Base.maximum(m::MyArray) = maximum(parent(m))\n\njulia> Base.minimum(m::MyArray) = minimum(parent(m))\n\njulia> @assignprops(\n           MyArray,\n           :my_properties => dictextension(calmax,calmin))","category":"page"},{"location":"adapting_existing_properties/#Changing-A-Property's-Behavior-1","page":"Changing A Property's Behavior","title":"Changing A Property's Behavior","text":"","category":"section"},{"location":"adapting_existing_properties/#","page":"Changing A Property's Behavior","title":"Changing A Property's Behavior","text":"If a previously defined property needs a different type or default output, we can just create unique proptype and propdefault methods.","category":"page"},{"location":"adapting_existing_properties/#","page":"Changing A Property's Behavior","title":"Changing A Property's Behavior","text":"julia> @defprop Property3{:prop3}::Int=1\n\njulia> struct MyStruct end\n\njulia> FieldProperties.proptype(::Type{<:Property3}, ::Type{<:MyStruct}) = String\n\njulia> FieldProperties.propdefault(::Type{<:Property3}, ::Type{<:MyStruct}) = \"\"","category":"page"},{"location":"adapting_existing_properties/#","page":"Changing A Property's Behavior","title":"Changing A Property's Behavior","text":"MyStruct isn't particularly interesting but it could contain, nested property fields, a dictionary for optional properties, or just fields for prop3. In such cases it's common to use something like prop3(x::MyStruct) = get(x, :prop3, \"\") to ensue a dictionary still returns something appropriate. However, this doesn't provide type stability, check nested fields for the property, or automatically convert returned values to the appropriate type.","category":"page"},{"location":"adapting_existing_properties/#","page":"Changing A Property's Behavior","title":"Changing A Property's Behavior","text":"TODO: more detail","category":"page"},{"location":"creating_properties/#Creating-Properties-1","page":"Creating Properties","title":"Creating Properties","text":"","category":"section"},{"location":"creating_properties/#Property-types-and-interface-1","page":"Creating Properties","title":"Property types and interface","text":"","category":"section"},{"location":"creating_properties/#","page":"Creating Properties","title":"Creating Properties","text":"AbstractProperty\npropname\nproptype\npropconvert","category":"page"},{"location":"creating_properties/#FieldProperties.AbstractProperty","page":"Creating Properties","title":"FieldProperties.AbstractProperty","text":"AbstractProperty{name}\n\nA AbstractProperty serves as a common reference point for accessing methods related to name, where name is the dot accessed field (as in x.<name>).\n\nSee @defprop, @properties\n\n\n\n\n\n","category":"type"},{"location":"creating_properties/#FieldProperties.propname","page":"Creating Properties","title":"FieldProperties.propname","text":"propname(x) -> Symbol\n\nReturns the symbolic name of a property.\n\n\n\n\n\n","category":"function"},{"location":"creating_properties/#FieldProperties.proptype","page":"Creating Properties","title":"FieldProperties.proptype","text":"proptype(p, context) -> Type\n\nReturn the appropriate type for property p given context. This method allows unique type restrictions given different types for context.\n\n\n\n\n\n","category":"function"},{"location":"creating_properties/#FieldProperties.propconvert","page":"Creating Properties","title":"FieldProperties.propconvert","text":"propconvert(p, context, v)\n\nEnsures the value v is the appropriate type for property p given context. If v isn't the appropriate type then propconvert attempts to convert to the \"correct type\". The \"correct type\" is determined by proptype(p, x).\n\nThis is functionlly equivalent to convert(proptype(p, x), v).\n\n\n\n\n\n","category":"function"},{"location":"creating_properties/#Simple-property-construction-1","page":"Creating Properties","title":"Simple property construction","text":"","category":"section"},{"location":"creating_properties/#","page":"Creating Properties","title":"Creating Properties","text":"@defprop","category":"page"},{"location":"creating_properties/#FieldProperties.@defprop","page":"Creating Properties","title":"FieldProperties.@defprop","text":"@defprop Property{name}::Type block\n\nConvient way of creating properties that wrap getproperty and setproperty! methods.\n\nExamples\n\nThe simplest form simply creates a getter and setter.\n\njulia> using FieldProperties\n\njulia> @defprop Property1{:prop1}\n\njulia> propname(prop1)\n:prop1\n\njulia> proptype(prop1)\nAny\n\njulia> prop1\nprop1 (generic function with 1 method)\n\njulia> prop1!\nprop1! (generic function with 1 method)\n\nDefine the propertie's type\n\njulia> @defprop Property2{:prop2}::Int\n\njulia> propname(prop2)\n:prop2\n\njulia> proptype(prop2)\nInt64\n\nDefine type requirement and default value.\n\njulia> @defprop Property3{:prop3}::Int begin\n           @getproperty x -> 1\n       end\n\njulia> propname(prop3)\n:prop3\n\njulia> proptype(prop3)\nInt64\n\njulia> prop3(3)\n1\n\nDefine a default value but no enforced return type but multiple getproperty methods.\n\njulia> @defprop Property4{:prop4} begin\n           @getproperty x::Int -> 1\n           @getproperty x::String -> \"1\"\n       end\n\njulia> propname(prop4)\n:prop4\n\njulia> proptype(prop4)\nAny\n\njulia> prop4(1)\n1\n\njulia> prop4\nprop4 (generic function with 3 methods)\n\njulia> prop4!\nprop4! (generic function with 1 method)\n\n\n\n\n\n","category":"macro"},{"location":"general_properties/#General-Properties-1","page":"General Properties","title":"General Properties","text":"","category":"section"},{"location":"general_properties/#","page":"General Properties","title":"General Properties","text":"FieldProperties.Description\n\nFieldProperties.Label\n\nFieldProperties.CalibrationMaximum\n\nFieldProperties.CalibrationMinimum","category":"page"},{"location":"general_properties/#FieldProperties.Description","page":"General Properties","title":"FieldProperties.Description","text":"Description that may say whatever you like.\n\n\n\n\n\n","category":"type"},{"location":"general_properties/#FieldProperties.Label","page":"General Properties","title":"FieldProperties.Label","text":"Property providing label for parent structure.\n\n\n\n\n\n","category":"type"},{"location":"general_properties/#FieldProperties.CalibrationMaximum","page":"General Properties","title":"FieldProperties.CalibrationMaximum","text":"Specifies maximum element for display purposes. If not specified returns the maximum value in the collection.\n\n\n\n\n\n","category":"type"},{"location":"general_properties/#FieldProperties.CalibrationMinimum","page":"General Properties","title":"FieldProperties.CalibrationMinimum","text":"Specifies minimum element for display purposes. If not specified returns the minimum value in the collection.\n\n\n\n\n\n","category":"type"},{"location":"finicky_api/#Finicky-API-1","page":"Finicky API","title":"Finicky API","text":"","category":"section"},{"location":"finicky_api/#","page":"Finicky API","title":"Finicky API","text":"TODO","category":"page"},{"location":"internal_design/#Internals-Design-1","page":"Internals Design","title":"Internals Design","text":"","category":"section"},{"location":"internal_design/#","page":"Internals Design","title":"Internals Design","text":"The fully defined property @defprop PropertyType{:prop}::T=D has 4 components","category":"page"},{"location":"internal_design/#","page":"Internals Design","title":"Internals Design","text":"PropertyType: conrete subtype of AbstractProperty\n:prop: the properties symbolic name\nT: The type restriction that ensures that a retrieved property is either convert to are already is <:T. T may be alternatively replaced with an anonymous function.\nD: The default type. D may also be replaced with an anonymous function.","category":"page"},{"location":"internal_design/#","page":"Internals Design","title":"Internals Design","text":"The previous example is equivalent to:","category":"page"},{"location":"internal_design/#","page":"Internals Design","title":"Internals Design","text":"struct PropertyType{T} <: AbstractProperty{:prop,T} end\n\n# getter function\nconst prop = PropertyType{Getter}()\n\n# setter function\nconst prop! = PropertyType{Setter}()\n\nFieldProperties.get_setter(::Type{<:PropertyType}) = prop!\n\nFieldProperties.get_getter(::Type{<:PropertyType}) = prop\n\nFieldProperties.propdefault(::Type{<:PropertyType}, x) = D\n\nFieldProperties.proptype(::Type{<:PropertyType}, x) = T","category":"page"},{"location":"internal_design/#","page":"Internals Design","title":"Internals Design","text":"If instead anonymous functions are used to define the type and default such as, @defprop PropertyType{:prop}::(y -> eltype(y))= y -> maximum(y) then the last two methods are defined as:","category":"page"},{"location":"internal_design/#","page":"Internals Design","title":"Internals Design","text":"\nFieldProperties.propdefault(::Type{<:PropertyType}, y) = maximum(y)\n\nFieldProperties.proptype(::Type{<:PropertyType}, y) = eltype(y)","category":"page"},{"location":"internal_design/#","page":"Internals Design","title":"Internals Design","text":"Note that the variable passed to the anonmyous function are captured in the creation of the the new method. if x -> eltype(y) was used there would be an error when trying to use proptype.","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Herein the term \"properties\" is used to refer to any single piece of data that is stored within another structure and \"metadata\" refers to the entire collection of properties that belongs to a structure. Some additional characteristics of properties (according to the definition used in this package) are:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"They are not necessarily known at compile time (much like the elements of an array or values in a dictionary)\nThey carry semantic meaning that may be shared across structures (similar to eltype or ndims for arrays)\nThey may have different characteristic in different contexts (mutable/immutable in certain structures or even optionally defined)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This package was created while trying to balance the following goals:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Extensibility: Easy for developers to add new properties while using those previously defined\nUsability: It shouldn't make it harder for users to access or interact with properties.\nOptimization: It should be possible to optimize performance of accessing and setting properties without violating the first 2 goals.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"ImageMetadata.jl, MetadataArrays.jl, and MetaGraph.jl are just a few packages that provide a way of adding metadata to array or graph structures. FieldMetadata.jl allows creating methods that produce \"metadata\" at each field of a structure. These packages provide similar functionality but have little overlap in the core functionality used here. Therefore, this package may be seen as complementary to these.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"There are some packages that have significant overlap with FieldProperties. MacroTools.jl provides @forward which conveniently maps method definitions to specific fields of structures. This overlaps with a great deal of what @properties does. However, @forward is strictly for methods (not properties) and there are some benefits to using @properties. There are many packages aimed at metaprogramming that appear to have very similar utilities. However, FieldProperties was created because none of them appeared to accomplish all the previously mentioned goals and there wasn't a clear path forward in using them together to accomplish those goals.","category":"page"}]
}
