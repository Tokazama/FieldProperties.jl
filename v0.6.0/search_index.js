var documenterSearchIndex = {"docs":
[{"location":"example_module/#ExampleModule-1","page":"Example Module","title":"ExampleModule","text":"","category":"section"},{"location":"example_module/#","page":"Example Module","title":"Example Module","text":"The following docstring was generated using the GETPROPERTY and SETPROPERTY abbreviations. These are an extension of DocStringExtensions that insert docstrings from @properties into a list. The actually code used to generate this can can be found in docs/ExampleModuele/src/ExampleModuele.jl.","category":"page"},{"location":"example_module/#","page":"Example Module","title":"Example Module","text":"Modules = [ExampleModule]","category":"page"},{"location":"example_module/#ExampleModule.ExampleStruct","page":"Example Module","title":"ExampleModule.ExampleStruct","text":"ExampleStruct\n\n\n\nprop1: retrieve the prop1 field\n\n\n\nprop1: set the prop1 field\n\n\n\n\n\n","category":"type"},{"location":"adapting_existing_properties/#Changing-A-Property's-Behavior-1","page":"Changing A Property's Behavior","title":"Changing A Property's Behavior","text":"","category":"section"},{"location":"adapting_existing_properties/#","page":"Changing A Property's Behavior","title":"Changing A Property's Behavior","text":"If a previously defined property needs a different type or default output, we can just create unique proptype and propdefault methods.","category":"page"},{"location":"adapting_existing_properties/#","page":"Changing A Property's Behavior","title":"Changing A Property's Behavior","text":"julia> @defprop Property3{:prop3}::Int=1\n\njulia> struct MyStruct end\n\njulia> FieldProperties.proptype(::Type{<:Property3}, ::Type{<:MyStruct}) = String\n\njulia> FieldProperties.propdefault(::Type{<:Property3}, ::Type{<:MyStruct}) = \"\"","category":"page"},{"location":"adapting_existing_properties/#","page":"Changing A Property's Behavior","title":"Changing A Property's Behavior","text":"MyStruct isn't particularly interesting but it could contain, nested property fields, a dictionary for optional properties, or just fields for prop3. In such cases it's common to use something like prop3(x::MyStruct) = get(x, :prop3, \"\") to ensue a dictionary still returns something appropriate. However, this doesn't provide type stability, check nested fields for the property, or automatically convert returned values to the appropriate type.","category":"page"},{"location":"adapting_existing_properties/#","page":"Changing A Property's Behavior","title":"Changing A Property's Behavior","text":"TODO: more detail","category":"page"},{"location":"structures_with_properties/#Structures-With-Properties-1","page":"Structures With Properties","title":"Structures With Properties","text":"","category":"section"},{"location":"structures_with_properties/#","page":"Structures With Properties","title":"Structures With Properties","text":"Although properties can be used flexibly with different structures, it may be easier to take advantage of the provided AbstractMetadata type. In the following example we take advantage of the Description and DictExtension. These provide a method of describing a structure and an extensible pool for storing an arbitrary number of properties.","category":"page"},{"location":"structures_with_properties/#","page":"Structures With Properties","title":"Structures With Properties","text":"julia> mutable struct MyProperties{M} <: AbstractMetadata{M}\n           my_description::String\n           my_properties::M\n       end","category":"page"},{"location":"structures_with_properties/#","page":"Structures With Properties","title":"Structures With Properties","text":"Binding Description and DictExtension to specific fields is accomplished through @assignprops. Several other methods specific to MyProperties are created to provide property like behavior. Most notably, the methods from base overwritten are getproperty, setproperty!, and propertynames.","category":"page"},{"location":"structures_with_properties/#","page":"Structures With Properties","title":"Structures With Properties","text":"julia> @properties MyProperties begin\n           description(x) => :my_description\n           description!(x, val) => :my_description\n           Any(x) => :my_properties\n           Any!(x, val) => (:my_properties)\n       end\n\njulia> m = MyProperties(\"\", Dict{Symbol,Any}())\nMyProperties{Dict{Symbol,Any}} with 1 entry\n    description:\n\njulia> propertynames(m)\n(:description,)","category":"page"},{"location":"structures_with_properties/#","page":"Structures With Properties","title":"Structures With Properties","text":"julia> description(m)\n\"\"\n\njulia> description!(m, \"foo\")\nMyProperties{Dict{Symbol,Any}} with 1 entry\n    description: foo\n\njulia> description(m)\n\"foo\"\n\njulia> m.description = \"bar\"\n\"bar\"\n\njulia> description(m)\n\"bar\"\n\njulia> m.description\n\"bar\"","category":"page"},{"location":"structures_with_properties/#","page":"Structures With Properties","title":"Structures With Properties","text":"Optional properties can be assigned to the DictExtension using the DictExtension(Propert1, Property2) syntax.","category":"page"},{"location":"structures_with_properties/#","page":"Structures With Properties","title":"Structures With Properties","text":"julia> @defprop CalibrationMaximum{:calmax}\n\njulia> propdefault(::CalibrationMaximumType, x::AbstractArray) = maximum(x)\n\njulia> proptype(::CalibrationMaximumType, ::Type{<:AbstractArray{T,N}}) where {T,N} = T\n\njulia> @defprop CalibrationMinimum{:calmin}\n\njulia> propdefault(::CalibrationMinimumType, x::AbstractArray) = minimum(x)\n\njulia> proptype(::CalibrationMinimumType, ::Type{<:AbstractArray{T,N}}) where {T,N} = T\n\njulia> struct MyArray{T,N,P<:AbstractArray{T,N},M<:AbstractDict{Symbol,Any}} <: AbstractArray{T,N}\n           _parent::P\n           my_properties::M\n       end\n\njulia> Base.parent(m::MyArray) = getfield(m, :_parent)\n\njulia> Base.size(m::MyArray) = size(parent(m))\n\njulia> Base.maximum(m::MyArray) = maximum(parent(m))\n\njulia> Base.minimum(m::MyArray) = minimum(parent(m))\n\njulia> @assignprops(\n           MyArray,\n           :my_properties => dictextension(calmax,calmin))","category":"page"},{"location":"onset/#The-onset-Property-1","page":"The onset Property","title":"The onset Property","text":"","category":"section"},{"location":"onset/#","page":"The onset Property","title":"The onset Property","text":"Knowing the onset of some time related event is useful for different analyses, but is encoded within different type structures in a way that may be incompatible for a single universal method. Here we define a property that has default functionality and then build on it for custom types. Throughout this process we try to ensure type stability.","category":"page"},{"location":"onset/#Defining-onset-1","page":"The onset Property","title":"Defining onset","text":"","category":"section"},{"location":"onset/#","page":"The onset Property","title":"The onset Property","text":"Here we define the onset property and assume that if it's called on any subtype of AbstractArray that it the first axis refers to the time domain.","category":"page"},{"location":"onset/#","page":"The onset Property","title":"The onset Property","text":"julia> using FieldProperties\n\njulia> @defprop Onset{:onset} begin\n           # assume the axis represents time\n           @getproperty x::AbstractArray -> first(axes(x, 1))\n       end\n\njulia> onset(rand(2,2))\n1\n\njulia> @code_warntype (onset(rand(2,2)))\nVariables\n  #self#::Core.Compiler.Const(onset (generic function with 3 methods), false)\n  x::Array{Float64,2}\n\nBody::Int64\n1 ─ %1 = Main.axes(x, 1)::Base.OneTo{Int64}\n│   %2 = Main.first(%1)::Core.Compiler.Const(1, false)\n└──      return %2","category":"page"},{"location":"onset/#Custom-Type-1","page":"The onset Property","title":"Custom Type","text":"","category":"section"},{"location":"onset/#","page":"The onset Property","title":"The onset Property","text":"Now let's define a very basic type for described an event at a particular time.","category":"page"},{"location":"onset/#","page":"The onset Property","title":"The onset Property","text":"julia> struct TimeEvent\n           description::String\n           onset::Int\n       end\n\njulia> te = TimeEvent(\"this time event\", 2);\n\njulia> onset(te)\n2\n\n# equivalent to...\njulia> te.onset\n2\n\njulia> @code_warntype onset(te)\nVariables\n  p::Core.Compiler.Const(onset (generic function with 3 methods), false)\n  x::TimeEvent\n\nBody::Int64\n1 ─ %1 = FieldProperties.getproperty(x, $(Expr(:static_parameter, 1)))::Int64\n│   %2 = FieldProperties.propconvert(p, x, %1)::Int64\n└──      return %2","category":"page"},{"location":"onset/#","page":"The onset Property","title":"The onset Property","text":"Notice that we can still access the onset field here without any sort of method overloading. We also don't lose type stability. This is because our initial definition of the onset property only overloads the getproperty version for subtypes of AbstractArray. Therefore, the default method is simply getproperty(x, :onset), which is equivalent to x.onset for our TimeEvent type.","category":"page"},{"location":"onset/#Optional-Presence-of-onset-1","page":"The onset Property","title":"Optional Presence of onset","text":"","category":"section"},{"location":"onset/#","page":"The onset Property","title":"The onset Property","text":"Now let's use the Metadata type to optionally store the onset property.","category":"page"},{"location":"onset/#","page":"The onset Property","title":"The onset Property","text":"julia> m = Metadata();\n\njulia> m.onset = 2\n2\n\njulia> onset(m)\n2\n\njulia> @code_warntype onset(m)\nVariables\n  p::Core.Compiler.Const(onset (generic function with 3 methods), false)\n  x::Metadata{Dict{Symbol,Any}}\n\nBody::Any\n1 ─ %1 = FieldProperties.getproperty(x, $(Expr(:static_parameter, 1)))::Any\n│   %2 = FieldProperties.propconvert(p, x, %1)::Any\n└──      return %2","category":"page"},{"location":"onset/#","page":"The onset Property","title":"The onset Property","text":"We can overcome problems with type stability by enforcing the returned type through onset_type (which was created with our original call to @defprop). We also can change the return type using this same method.","category":"page"},{"location":"onset/#","page":"The onset Property","title":"The onset Property","text":"julia> onset_type(m::Metadata) = Float64\nonset(eltype) (generic function with 3 methods)\n\njulia> @code_warntype onset(m)\nVariables\n  p::Core.Compiler.Const(onset (generic function with 3 methods), false)\n  x::Metadata{Dict{Symbol,Any}}\n\nBody::Float64\n1 ─ %1 = FieldProperties.getproperty(x, $(Expr(:static_parameter, 1)))::Any\n│   %2 = FieldProperties.propconvert(p, x, %1)::Float64\n└──      return %2\n\njulia> onset(m)\n2.0","category":"page"},{"location":"onset/#","page":"The onset Property","title":"The onset Property","text":"This is functionally similar to writing onset(m::Metadata) = convert(Float64, getproperty(m, :onset)).","category":"page"},{"location":"properties/#Properties-1","page":"Properties","title":"Properties","text":"","category":"section"},{"location":"properties/#What-are-properties?-1","page":"Properties","title":"What are properties?","text":"","category":"section"},{"location":"properties/#","page":"Properties","title":"Properties","text":"The term properties in this package originates from how it is used in base Julia (propertynames, getproperty, setproperty!). Each of these methods is covered in detail in the Julia's documentation, so here we focus only on a few key points.","category":"page"},{"location":"properties/#","page":"Properties","title":"Properties","text":"\"Properties\" are accessed via the dot operator.\n\"Fields\" are the explicit names used in the definition of a structure.\nThe default properties of an instance of a structure are its fields.\nFields can ALWAYS be accessed using getfield and setfield!","category":"page"},{"location":"properties/#","page":"Properties","title":"Properties","text":"julia> struct SomeType\n           field  # this is a field\n       end\n\n\njulia> x = SomeType(1)\nSomeType(1)\n\n# dot operator used as syntactic sugar for getproperty which then calls getfield\njulia> x.field == getproperty(x, :field) == getfield(x, :field)\ntrue\n\njulia> Base.getproperty(x::SomeType, p::Symbol) = p === :property ? getfield(x, :field) : error(\"$p is not a property of SomeType\")\n\n# \"field\" is no longer a property of SomeType\njulia> x.field\nERROR: field is not a property of SomeType\n[...]\n\n# \"field\" is still considered a field of SomeType but the only property is \"property\" now\njulia> x.property == getproperty(x, :property) == getfield(x, :field)\ntrue","category":"page"},{"location":"properties/#Creating-Properties-1","page":"Properties","title":"Creating Properties","text":"","category":"section"},{"location":"properties/#","page":"Properties","title":"Properties","text":"When a dot operator call getproperty or setproperty! it represent the property as a Symbol. Sometimes it's useful to have a method that retrieves a specific property so that users have a common API that doesn't change despite changes in the internal structure of types. @defprop automatically creates a method that calls getproperty and a method that calls setproperty!. This permits a sort of duck typing that can also be optimized for compile time performance. This section describes how to create properties quickly and some ways of customizing the behavior.","category":"page"},{"location":"properties/#Assigning-Properties-1","page":"Properties","title":"Assigning Properties","text":"","category":"section"},{"location":"properties/#","page":"Properties","title":"Properties","text":"@properties makes it easy to create new properties for a given type. Conceptually, it allows one to create a type structure that has fields focused on efficient design and then provide a user facing set of properties to access them. It may be useful to define a set of methods using @defprop and then assign the relevant fields to a custom structure.","category":"page"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Index-1","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [FieldProperties]","category":"page"},{"location":"reference/#Documentation-1","page":"Reference","title":"Documentation","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [FieldProperties]","category":"page"},{"location":"reference/#FieldProperties.FieldProperties","page":"Reference","title":"FieldProperties.FieldProperties","text":"FieldProperties.jl\n\n(Image: Build Status) (Image: codecov)\n\nFieldProperties provides an interface for creating method/property based APIs that can be flexibly incorporated into Julia structures. This is predominantly accomplished through the use of @defprop and @properties. These macros help in the creation of methods and mapping them to the fields of a concrete type.\n\n\n\n\n\n","category":"module"},{"location":"reference/#FieldProperties.AbstractProperty","page":"Reference","title":"FieldProperties.AbstractProperty","text":"AbstractProperty{name}\n\nA AbstractProperty serves as a common reference point for accessing methods related to name, where name is the dot accessed field (as in x.<name>).\n\nSee @defprop, @properties\n\n\n\n\n\n","category":"type"},{"location":"reference/#FieldProperties.AbstractPropertyList","page":"Reference","title":"FieldProperties.AbstractPropertyList","text":"AbstractPropertyList{M <: AbstractDict{Symbol,Any}} <: AbstractDict{Symbol,Any}\n\nAbstract type for storing metadata.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FieldProperties.NoopPropertyList","page":"Reference","title":"FieldProperties.NoopPropertyList","text":"NoopPropertyList\n\nEmpty dictionary that indicates there is no metadata.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FieldProperties.PropertyList","page":"Reference","title":"FieldProperties.PropertyList","text":"PropertyList{D}\n\nSubtype of AbstractPropertyList that provides getproperty syntax for accessing the values of a dictionary.\n\nExamples\n\njulia> using FieldProperties\n\njulia> m = PropertyList(; a = 1, b= 2)\nPropertyList{Dict{Symbol,Any}} with 2 entries\n    a: 1\n    b: 2\n\njulia> getindex(m, :a)\n1\n\njulia> get(m, :a, 3)\n1\n\njulia> get!(m, :a, 3)\n1\n\njulia> m.a\n1\n\njulia> m[:a] = 2\n2\n\njulia> m.a\n2\n\njulia> m.b\n2\n\njulia> m.b = 3\n3\n\njulia> m.b\n3\n\njulia> m.name = \"ridiculously long name that we don't want to print everytime the other properties are printed.\";\n\n\njulia> m.suppress = (:name,)\n(:name,)\n\njulia> m\nPropertyList{Dict{Symbol,Any}} with 4 entries\n    a: 2\n    b: 3\n    name: <suppressed>\n    suppress: (:name,)\n\n\n\n\n\n","category":"type"},{"location":"reference/#FieldProperties.calmax","page":"Reference","title":"FieldProperties.calmax","text":"calmax(x)\ncalmax!(x, val)\n\nSpecifies maximum element for display purposes. If not specified returns the maximum value in the collection.\n\nExamples\n\njulia> using FieldProperties\n\njulia> x = reshape(1:16, 4, 4);\n\njulia> calmax(x)\n16\n\njulia> struct ArrayMaxThresh{T,N}\n           a::AbstractArray{T,N}\n           calmax::T\n       end\n\njulia> calmax(ArrayMaxThresh(x, 10))\n10\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#FieldProperties.calmax!","page":"Reference","title":"FieldProperties.calmax!","text":"calmax(x)\ncalmax!(x, val)\n\nSpecifies maximum element for display purposes. If not specified returns the maximum value in the collection.\n\nExamples\n\njulia> using FieldProperties\n\njulia> x = reshape(1:16, 4, 4);\n\njulia> calmax(x)\n16\n\njulia> struct ArrayMaxThresh{T,N}\n           a::AbstractArray{T,N}\n           calmax::T\n       end\n\njulia> calmax(ArrayMaxThresh(x, 10))\n10\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#FieldProperties.calmin","page":"Reference","title":"FieldProperties.calmin","text":"calmin(x)\ncalmin!(x, val)\n\nSpecifies minimum element for display purposes. If not specified returns the minimum value in the collection.\n\nExamples\n\njulia> using FieldProperties\n\njulia> x = reshape(1:16, 4, 4);\n\njulia> calmin(x)\n1\n\njulia> struct ArrayMinThresh{T,N}\n           a::AbstractArray{T,N}\n           calmin::T\n       end\n\njulia> calmin(ArrayMinThresh(x, 5))\n5\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#FieldProperties.calmin!","page":"Reference","title":"FieldProperties.calmin!","text":"calmin(x)\ncalmin!(x, val)\n\nSpecifies minimum element for display purposes. If not specified returns the minimum value in the collection.\n\nExamples\n\njulia> using FieldProperties\n\njulia> x = reshape(1:16, 4, 4);\n\njulia> calmin(x)\n1\n\njulia> struct ArrayMinThresh{T,N}\n           a::AbstractArray{T,N}\n           calmin::T\n       end\n\njulia> calmin(ArrayMinThresh(x, 5))\n5\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#FieldProperties.description","page":"Reference","title":"FieldProperties.description","text":"description(x) -> String\n\nDescription that may say whatever you like.\n\n\n\ndescription(x::AbstractProperty) -> String\n\nReturns description for property x.\n\nExamples\n\njulia> using FieldProperties\n\njulia> description(description)\n\"Description that may say whatever you like.\\n\"\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#FieldProperties.description!","page":"Reference","title":"FieldProperties.description!","text":"description(x) -> String\n\nDescription that may say whatever you like.\n\n\n\ndescription(x::AbstractProperty) -> String\n\nReturns description for property x.\n\nExamples\n\njulia> using FieldProperties\n\njulia> description(description)\n\"Description that may say whatever you like.\\n\"\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#FieldProperties.description_list-Tuple","page":"Reference","title":"FieldProperties.description_list","text":"description_list(ps...) -> String\n\nReturns a markdown list where eache element of ps is formatted as:\n\n* name(ps[i]): description(ps[i]).\n\nExamples\n\njulia> using FieldProperties\n\njulia> description_list(description, calmax)\n\"* `description`: Description that may say whatever you like.\\n* `calmax`: Specifies maximum element for display purposes. If not specified returns the maximum value in the collection.\\n\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#FieldProperties.label","page":"Reference","title":"FieldProperties.label","text":"Property providing label for parent structure.\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#FieldProperties.label!","page":"Reference","title":"FieldProperties.label!","text":"Property providing label for parent structure.\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#FieldProperties.name","page":"Reference","title":"FieldProperties.name","text":"name(x) -> Symbol\nname!(x, val)\n\nProperty providing name for parent structure.\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#FieldProperties.name!","page":"Reference","title":"FieldProperties.name!","text":"name(x) -> Symbol\nname!(x, val)\n\nProperty providing name for parent structure.\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#FieldProperties.name-Union{Tuple{P}, Tuple{P}} where P<:AbstractProperty","page":"Reference","title":"FieldProperties.name","text":"name(x::AbstractProperty) -> Symbol\n\nReturns the symbolic name of the property.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FieldProperties.propconvert-Tuple{Any,Any,Any}","page":"Reference","title":"FieldProperties.propconvert","text":"propconvert(p, context, v)\n\nEnsures the value v is the appropriate type for property p given context. If v isn't the appropriate type then propconvert attempts to convert to the \"correct type\".\n\n\n\n\n\n","category":"method"},{"location":"reference/#FieldProperties.status","page":"Reference","title":"FieldProperties.status","text":"No documentation found.\n\nFieldProperties.Status is of type UnionAll.\n\nSummary\n\nstruct UnionAll <: Type{T}\n\nFields\n\nvar  :: TypeVar\nbody :: Any\n\nSupertype Hierarchy\n\nUnionAll <: Type{T} <: Any\n\n\n\n","category":"function"},{"location":"reference/#FieldProperties.status!","page":"Reference","title":"FieldProperties.status!","text":"No documentation found.\n\nFieldProperties.Status is of type UnionAll.\n\nSummary\n\nstruct UnionAll <: Type{T}\n\nFields\n\nvar  :: TypeVar\nbody :: Any\n\nSupertype Hierarchy\n\nUnionAll <: Type{T} <: Any\n\n\n\n","category":"function"},{"location":"reference/#FieldProperties.@defprop-Tuple{Any,Any}","page":"Reference","title":"FieldProperties.@defprop","text":"@defprop Property{name}::Type block\n\nConvient way of creating properties that wrap getproperty and setproperty! methods.\n\nExamples\n\nThe simplest form simply creates a getter and setter.\n\njulia> using FieldProperties\n\njulia> @defprop Property1{:prop1}\n\njulia> name(prop1)\n:prop1\n\njulia> prop1_type(:any_type)\nAny\n\nDefine the propertie's type\n\njulia> @defprop Property2{:prop2}::Int\n\njulia> name(prop2)\n:prop2\n\njulia> prop2_type(:any_type)\nInt64\n\nDefine type requirement and default value.\n\njulia> @defprop Property3{:prop3}::Int begin\n           @getproperty x -> 1\n       end\n\njulia> name(prop3)\n:prop3\n\njulia> prop3_type(:any_type)\nInt64\n\njulia> prop3(3)\n1\n\nDefine a default value but no enforced return type but multiple getproperty methods.\n\njulia> @defprop Property4{:prop4} begin\n           @getproperty x::Int -> 1\n           @getproperty x::String -> \"1\"\n       end\n\njulia> name(prop4)\n:prop4\n\njulia> prop4_type(:any_type)\nAny\n\njulia> prop4(1)\n1\n\n\n\n\n\n","category":"macro"},{"location":"reference/#FieldProperties.@properties-Tuple{Any,Any}","page":"Reference","title":"FieldProperties.@properties","text":"@properties T block\n\nSyntactic sugar for custom getproperty, setproperty!, and propertynames methods. For any type T passed to @properties these methods will be rewritten from their default.\n\nExamples\n\nThe following syntax assigns property names to function calls.\n\njulia> using FieldProperties\n\njulia> mutable struct MyType\n           x::Int\n       end\n\njulia> @properties MyType begin\n           xint(self) = getfield(self, :x)\n           xint!(self, val) = setfield!(self, :x, val)\n           hello(self) = \"hello\"\n       end\n\njulia> mt = MyType(1)\nMyType(1)\n\njulia> mt.xint\n1\n\njulia> mt.xint = 2\n2\n\njulia> mt.xint\n2\n\njulia> mt.hello\n\"hello\"\n\njulia> propertynames(mt)\n(:xint, :hello)\n\njulia> mt.x\nERROR: Property x not found\n[...]\n\nThere are three things you should take away from this:\n\ngetproperty, setproperty!, and propertynames are completely overwritten here\nAny property assignment that ends with ! is used to assign a setproperty!\nMyType not longer can access the x field via mt.x (because of the first point).\n\nIt can be somewhat tedious to write out every getfield and setfield method, so let's redo this using => to assign fields\n\njulia> @properties MyType begin\n           xint(self) => :x\n           xint!(self, val) => :x\n           hello(self) = \"hello\"\n       end\n\njulia> mt = MyType(1)\nMyType(1)\n\njulia> mt.xint\n1\n\njulia> mt.xint = 2\n2\n\njulia> mt.xint\n2\n\njulia> mt.hello\n\"hello\"\n\njulia> propertynames(mt)\n(:xint, :hello)\n\njulia> mt.x\nERROR: Property x not found\n[...]\n\nSometimes we want to use a modular approach to constructing a type. The following example requires users to know where to find the x1, x2, and x3 fields.\n\njulia> mutable struct PropList1\n           x2::Int\n       end\n\njulia> mutable struct PropList2\n           x3::Int\n       end\n\njulia> mutable struct MyProperties\n           x1::Int\n           l1::PropList1\n           l2::PropList2\n       end\n\njulia> mp = MyProperties(1, PropList1(2), PropList2(3))\nMyProperties(1, PropList1(2), PropList2(3))\n\njulia> mp.x1\n1\n\njulia> mp.l1.x2  # obnoxious for users\n2\n\njulia> mp.l2.x3  # also obnoxious for users\n3\n\nThe following syntax tells our property methods to search through nested fields.\n\njulia> @properties MyProperties begin\n           x1(self) => :x1\n           x1!(self, val) => :x1\n           Any(self) => (:l1, :l2)\n           Any!(self, val) => (:l1, :l2)\n       end\n\njulia> propertynames(mp)\n(:x1, :x2, :x3)\n\njulia> mp.x1\n1\n\njulia> mp.x2\n2\n\njulia> mp.x3\n3\n\nThe last two methods (Any(x) and Any!(x, val)) tell the getproperty and setproperty! methods search the l1 and l2 fields for any property that isn't :x1.\n\nThe lowered code is:\n\njulia> @macroexpand @properties MyProperties begin\n                  x1(self) => :x1\n                  x1!(self, val) => :x1\n                  Any(self) => (:l1, :l2)\n                  Any!(self, val) => (:l1, :l2)\n              end\nquote\n    function Base.getproperty(self::MyProperties, p::Symbol)\n        if p === :x1\n            getfield(self, :x1)\n        else\n            if hasproperty(getfield(self, :l1), p)\n                getproperty(getfield(self, :l1), p)\n            else\n                getproperty(getfield(self, :l2), p)\n            end\n        end\n    end\n    function Base.setproperty!(self::MyProperties, p::Symbol, val)\n        if p === :x1\n            setfield!(self, :x1, val)\n        else\n            if hasproperty(getfield(self, :l1), p)\n                setproperty!(getfield(self, :l1), p, val)\n            else\n                setproperty!(getfield(self, :l2), p, val)\n            end\n        end\n    end\n    function Base.propertynames(self::MyProperties)\n        (:x1, propertynames(getfield(self, :l1))..., propertynames(getfield(self, :l2))...)\n    end\nend\n\nNote that the the :l1 and l2 fields are searched in the same order they are called inside the macro (e.g., Any(x) => (:l1, :l2) results in searching :l1 then :l2).\n\n\n\n\n\n","category":"macro"},{"location":"reference/#FieldProperties.CalibrationMaximum","page":"Reference","title":"FieldProperties.CalibrationMaximum","text":"calmax(x)\ncalmax!(x, val)\n\nSpecifies maximum element for display purposes. If not specified returns the maximum value in the collection.\n\nExamples\n\njulia> using FieldProperties\n\njulia> x = reshape(1:16, 4, 4);\n\njulia> calmax(x)\n16\n\njulia> struct ArrayMaxThresh{T,N}\n           a::AbstractArray{T,N}\n           calmax::T\n       end\n\njulia> calmax(ArrayMaxThresh(x, 10))\n10\n\n\n\n\n\n","category":"type"},{"location":"reference/#FieldProperties.CalibrationMinimum","page":"Reference","title":"FieldProperties.CalibrationMinimum","text":"calmin(x)\ncalmin!(x, val)\n\nSpecifies minimum element for display purposes. If not specified returns the minimum value in the collection.\n\nExamples\n\njulia> using FieldProperties\n\njulia> x = reshape(1:16, 4, 4);\n\njulia> calmin(x)\n1\n\njulia> struct ArrayMinThresh{T,N}\n           a::AbstractArray{T,N}\n           calmin::T\n       end\n\njulia> calmin(ArrayMinThresh(x, 5))\n5\n\n\n\n\n\n","category":"type"},{"location":"reference/#FieldProperties.Description","page":"Reference","title":"FieldProperties.Description","text":"description(x) -> String\n\nDescription that may say whatever you like.\n\n\n\ndescription(x::AbstractProperty) -> String\n\nReturns description for property x.\n\nExamples\n\njulia> using FieldProperties\n\njulia> description(description)\n\"Description that may say whatever you like.\\n\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#FieldProperties.Label","page":"Reference","title":"FieldProperties.Label","text":"Property providing label for parent structure.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FieldProperties.Name","page":"Reference","title":"FieldProperties.Name","text":"name(x) -> Symbol\nname!(x, val)\n\nProperty providing name for parent structure.\n\n\n\n\n\n","category":"type"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Herein the term \"properties\" is used to refer to any single piece of data that is stored within another structure and \"metadata\" refers to the entire collection of properties that belongs to a structure. Some additional characteristics of properties (according to the definition used in this package) are:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"They are not necessarily known at compile time (much like the elements of an array or values in a dictionary)\nThey carry semantic meaning that may be shared across structures (similar to eltype or ndims for arrays)\nThey may have different characteristic in different contexts (mutable/immutable in certain structures or even optionally defined)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This package was created while trying to balance the following goals:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Extensibility: Easy for developers to add new properties while using those previously defined\nUsability: It shouldn't make it harder for users to access or interact with properties.\nOptimization: It should be possible to optimize performance of accessing and setting properties without violating the first 2 goals.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"ImageMetadata.jl, MetadataArrays.jl, and MetaGraph.jl are just a few packages that provide a way of adding metadata to array or graph structures. FieldMetadata.jl allows creating methods that produce \"metadata\" at each field of a structure. These packages provide similar functionality but have little overlap in the core functionality used here. Therefore, this package may be seen as complementary to these.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"There are some packages that have significant overlap with FieldProperties. MacroTools.jl provides @forward which conveniently maps method definitions to specific fields of structures. This overlaps with a great deal of what @properties does. However, @forward is strictly for methods (not properties) and there are some benefits to using @properties. There are many packages aimed at metaprogramming that appear to have very similar utilities. However, FieldProperties was created because none of them appeared to accomplish all the previously mentioned goals and there wasn't a clear path forward in using them together to accomplish those goals.","category":"page"},{"location":"finding_jeff/#Finding-Jeff-1","page":"Finding Jeff","title":"Finding Jeff","text":"","category":"section"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"Let's say we have a property jeff. Much like the person, jeff is extremely useful to have around yet is difficult to consistently locate.","category":"page"},{"location":"finding_jeff/#Defining-jeff-1","page":"Finding Jeff","title":"Defining jeff","text":"","category":"section"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"Here the property jeff is defined.","category":"page"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"julia> @defprop Jeff{:jeff} begin\n           @getproperty x -> begin\n               if hasproperty(x, :jeff)\n                   return print(getproperty(x, :jeff))\n               else\n                   return print(\"Jeff is not here. You are alone...\\n\")\n               end\n           end\n           @setproperty! (x, val) -> begin\n               setproperty!(x, :jeff, \"I am Jeff. I give you \" * string(val) * \".\\n\")\n           end\n       end","category":"page"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"Now we use the Metadata type to store people we know.","category":"page"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"julia> m = Metadata()\nMetadata{Dict{Symbol,Any}} with 0 entries\n\njulia> jeff(m)\nJeff is not here. You are alone...\n\njulia> jeff!(m, \"beans\");\n\njulia>  jeff(m)\nI am Jeff. I give you beans.\n","category":"page"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"This doesn't effect the standard functionality of getproperty or setproperty for the Metadata type. The following doesn't print the String gives us the raw String we've stored instead of printing it.","category":"page"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"julia> m.jeff\n\"I am Jeff. I give you beans.\\n\"\n","category":"page"},{"location":"finding_jeff/#Locating-Jeff-1","page":"Finding Jeff","title":"Locating Jeff","text":"","category":"section"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"Perhaps we want to specifically store a list of people we know. Some people are pretty consistent so we can dedicate fields for them, but we still need to account for the transient state of Jeff (the person).","category":"page"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"julia> struct MyPeeps\n           mom::String\n           dad::String\n           sister::String\n           extension::Metadata\n       end\n\njulia> @properties MyPeeps begin\n           mom(x) => :mom\n           dad(x) => :dad\n           sister(x) => :sister\n           Any(x) => :extension\n           Any!(x, val) => :extension\n       end","category":"page"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"Now we define an instance of MyPeeps and access them.","category":"page"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"julia> peeps = MyPeeps(\"I am your mom.\\n\",\n                       \"I am your dad.\\n\",\n                       \"I am your sister.\\n\", Metadata());\njulia> peeps.mom\n\"I am your mom.\\n\"\n\njulia> peeps.dad\n\"I am your dad.\\n\"\n\njulia> peeps.sister\n\"I am your sister.\\n\"\n\njulia> jeff(peeps)\nJeff is not here. You are alone...\n\njulia> peeps.jeff = \"I am Jeff.\\n\";\n\njulia> jeff(peeps)\nI am Jeff.\n\n# make Jeff a little more useful\njulia> jeff(peeps)\nI am Jeff. I give you beans.","category":"page"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"This is a pretty simple setup of though. We probably know more people.","category":"page"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"julia> struct Children\n           child1::String\n           child2::String\n       end\n\njulia> struct Family\n           significant_other::String\n           children::Children\n       end\n\njulia> @properties Family begin\n           significant_other(self) => :significant_other\n           Any(self) => :children\n       end\n\njulia> struct ListOfPeeps\n           family::Family\n           peeps::MyPeeps\n       end\n\njulia> @properties ListOfPeeps begin\n           Any(self) => (:family,:peeps)\n           Any!(self, val) => (:family,:peeps)\n       end\n\n\njulia> list_o_peeps = ListOfPeeps(Family(\"I am your significant other.\\n\",\n                                         Children(\"Feed me.\\n\",\n                                                  \"Feed me too.\\n\")),\n                                  MyPeeps(\"I am your mom.\\n\",\n                                          \"I am your dad.\\n\",\n                                          \"I am your sister.\\n\", Metadata())\n                                  );\njulia> propertynames(list_o_peeps)\n(:significant_other, :child1, :child2, :mom, :dad, :sister)","category":"page"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"And yet we are so very alone.","category":"page"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"julia> jeff(list_o_peeps)\nJeff is not here. You are alone...\n","category":"page"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"However, if we should happen to find Jeff again we can keep track off him.","category":"page"},{"location":"finding_jeff/#","page":"Finding Jeff","title":"Finding Jeff","text":"julia> jeff!(list_o_peeps, \"beans\");\n\njulia> jeff(list_o_peeps)\nI am Jeff. I give you beans.\n","category":"page"}]
}
